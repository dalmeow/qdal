# Regression models: categorical predictors {#sec-regression-cat}

![](https://img.shields.io/badge/Area-R-green)

In @sec-regression you learned how to fit regression models of the following form in R using the brms package.

$$
\begin{align}
y & \sim Gaussian(\mu, \sigma)\\
\mu & = \beta_0 + \beta_1 \cdot x\\
\end{align}
$$

In these models, $x$ was a numeric predictor, like speech rate. Numeric predictors are not the only type of predictors that a regression model can handle. Regression predictors can also be categorical: gender, age group, place of articulation, mono- vs bi-lingual, etc. However, regression model cannot handle categorical predictors directly: think about it, what would it mean to multiply $\beta_1$ by "female" or by "old". Categorical predictors have to be re-coded as numbers.

In this chapter we will revisit the MALD reaction times (RTs) data from @sec-fit-model, this time modelling RTs depending on the lexical status of the target work (real vs nonce word). You will learn about two ways of coding categorical predictors: treatment contrasts (the default type in most implementations of regression models) and indexing.

## Revisiting reaction times

Let's read the MALD data [@tucker2019].

```{r}
#| label: mald
#| message: false

library(tidyverse)

mald <- readRDS("data/tucker2019/mald_1_1.rds")
mald
```

The relevant columns are `RT` with the RTs in milliseconds and `IsWord`, the type of target word: it tells if the target word is a real English word (`TRUE`) or not (a nonce word, `FALSE`). @fig-mald-dens shows the density plot of RTs, grouped by whether the target word is real or not. We can notice that the distribution of RTs with nonce (non-real) words is somewhat shifted towards higher RTs, indicating that more time is needed to process nonce words than real words.

```{r}
#| label: fig-mald-dens
#| fig-cap: "Density plot of reaction times from the MALD data [@tucker2019]."
#| code-fold: true

# Set the light theme for plots
theme_set(theme_light())

mald |> 
  ggplot(aes(RT, fill = IsWord)) +
  geom_density(alpha = 0.8) +
  geom_rug(alpha = 0.1) +
  scale_fill_brewer(palette = "Dark2")
```

::: {.callout-warning collapse="true"}
## Extra: Fill and colour aesthetics

...
:::

You might also notice that the "tails" of the distributions (the left and right sides) are not symmetric: the right tail is heavier that the left tail. This is a very common characteristics of RT values and of any variable that can only be positive (like phonetic durations). These variables are "bounded" to only positive numbers. You will learn later on that the values in these variables are generated by a log-normal distribution, rather than by a Gaussian distribution (which is "unbounded"). For the time being though, we will model the data as if they were generated by a Gaussian distribution, for pedagogical reasons.

Another way to present a numeric variable like RTs depending on categorical variables is to use a jitter plot, like @fig-mald-jit. A jitter plot places dots corresponding to the values in the data on "strips". The strips are created by randomly jittering dots horizontally, so that they don't all fall on a straight line. The width of the strips, aka the jitter, can be adjusted with the `width` argument. It's subtle, but you can see how in the range 1 to 2 seconds there are a bit more dots in nonce words (right, orange) than in real words (left, green). In other words, the density of dots in that range is greater in nonce words than real words. If you compare again the densities in @fig-mald-dens above, you will notice that the orange density in the 1-2 seconds range is higher in nonce words. These are just two ways of visualising the same thing.

```{r}
#| label: fig-mald-jit
#| fig-cap: "Jitter plot of reactions times for real and nonce words."

mald |>
  ggplot(aes(IsWord, RT, colour = IsWord)) +
  geom_jitter(alpha = 0.15, width = 0.1) +
  scale_colour_brewer(palette = "Dark2")
```

We can even overlay density plots on jitter plots using "violins", like in @fig-mald-jit-vio. The violins are simply mirrored density plots, placed vertically on top of the jittered strips. The width of the violins can be adjusted with the `width` argument, like with the jitter.

```{r}
#| label: fig-mald-jit-vio
#| fig-cap: "Jitter and violin plot of reactions times for real and nonce words."

mald |>
  ggplot(aes(IsWord, RT, fill = IsWord)) +
  geom_jitter(alpha = 0.15, width = 0.1) +
  geom_violin(width = 0.2) +
  scale_fill_brewer(palette = "Dark2")
```

Now we can obtain a few summary measures. The following code groups the data by `IsWord` and then calculates the mean, median and standard deviation of RTs.

```{r}
#| label: mald-summ
mald_summ <- mald |> 
  group_by(IsWord) |> 
  summarise(
    mean(RT), median(RT), sd(RT)
  )

mald_summ
```

::: {.callout-warning collapse="true"}
## Extra: Tables with `kable()`

With Quarto, you can output the summaries as a table, using `knitr::kable()`. You can learn more about this [here](https://quarto.org/docs/authoring/tables.html#computations).

```{r}
#| label: tbl-mald-summ
#| tbl-cap: "Mean, median and standard deviation of RTs for real and nonce words."

knitr::kable(
  mald_summ,
  digits = 0,
  col.names = c("Is word?", "mean", "median", "SD")
)

```
:::

## Model RTs by word type

We can model RTs with a Gaussian distribution (although as mentioned above, this family of distribution is generally not appropriate for variables liker RTs) with a mean \$\\mu\$ and a standard deviation $\sigma$. This time though we want to model a different mean $\mu$ depending on the word type in `IsWord`. Each observation (RT value) is either of a real word or a nonce word. This is what the subscript $i$ is for in the equation below:

$$
RT_i \sim Gaussian(\mu_i, \sigma)
$$

The mean $\mu_i$ will depend on the specific observation $RT_i$. We will see why in a second.

Now, how do we make the model estimate a different mean depending on `IsWord`. There are several ways of setting this up. The default method is to use so-called "treatment contrasts" coding of categorical predictors. Let's work by example with `IsWord`. This is a categorical predictor with two levels: `TRUE` and `FALSE`. With treatment contrasts, one level is chosen as the "reference" level and the other is compared to the reference level. The reference level is automatically set as the first level in the predictor in alphabetical order. This would mean that `FALSE` would be the reference level, because "F" comes before "T".

However, in the `mald` data, the column `IsWord` is a factor column and the levels have been ordered so that `TRUE` is the first level and `FALSE` the second. You can see this in the Environment panel, if you click on the arrow next to `mald` and look next to `IsWord`: it will say `Factor w/ 2 levels "TRUE","FALSE"`. You can also check the order of the levels of a factor with the `levels()` function.

```{r}
#| label: levels
levels(mald$IsWord)
```

You can set the order of the levels with the `factor()` function. If you don't specify the order of the levels, the alphabetical order will be used. For example:

```{r}
#| label: factor

fac <- tibble(
  fac = c("a", "a", "b", "b", "a"),
  fac_1 = factor(fac),
  fac_2 = factor(fac, levels = c("b", "a"))
)

levels(fac$fac_1)
levels(fac$fac_2)
```

We will use `IsWord` with the order `TRUE` and `FALSE`. This means that `TRUE` will be the reference level and the RTs when `IsWord` is `FALSE` will be compared to the RTs of when `IsWord` is `TRUE`. In other words, now the mean $\mu_i$ varies depending on the level of `IsWord`. Let's assume a "dummy variable" $w_i$ that says if `IsWord` is `TRUE`, in which case $w_i = 0$, or `FALSE`, in which case $w_i = 1$. See @tbl-treat.

| `IsWord`       | `w` |
|----------------|:---:|
| IsWord = TRUE  |  0  |
| IsWord = FALSE |  1  |

: Treatment contrasts coding of the categorical predictor `IsWord`. {#tbl-treat}

We can now write the equation of $\mu_i$ as in the following:

$$
\begin{align}
RT_i & \sim Gaussian(\mu_i, \sigma)\\
\mu_i & = \beta_0 + \beta_1 \cdot w_i\\
\end{align}
$$

$\beta_0$ and $\beta_1$ are two "regression coefficients", estimated from the data by the regression model. So $\mu_i$ is the sum of $\beta_0$ and $\beta_1 \cdot w_i$. $w_i$ is 0 (when the word is real) or 1 (the the word is a nonce word). The outcome of plugging in the value of $w_i$ is laid out in the following formulae.

$$
\begin{align}
\mu_i & = \beta_0 + \beta_1 \cdot w_i\\
\mu_{\text{T}} & = \beta_0 + \beta_1 \cdot 0 = \beta_0\\
\mu_{\text{F}} & = \beta_0 + \beta_1 \cdot 1 = \beta_0 + \beta_1
\end{align}
$$

-   When `IsWord` is `TRUE`, the mean RT is equal to $\beta_0$.

-   When `IsWord` is `FALSE`, the mean RT is equal to $\beta_0 + \beta_1$.

If $\beta_0$ is the *mean* RT when `IsWord` is TRUE, what is $\beta_1$ by itself? Simple.

$$
\begin{align}
\beta_1 & = \mu_\text{F} - \mu_\text{T}\\
& = (\beta_0 + \beta_1) - \beta_0
\end{align}
$$

$\beta_0$ is the *difference* between the mean RT when `IsWord` is TRUE and the mean RT when `IsWord` is FALSE. As mentioned above, with treatment contrasts you are comparing the second level to the first. So one regression coefficient will be the mean of the reference level, but the other coefficient will be the *difference* between the mean of the two levels. I know this is not particularly user-friendly, but this is the default in R when using categorical predictors. Fitting a regression model with a categorical predictor like `IsWord` is as simple as including the predictor in the model formula, to the right of the tilde `~`.

```{r}
#| label: rt-bm-1
#| message: false
#| warning: false

library(brms)

rt_bm_1 <- brm(
  RT ~ IsWord,
  family = gaussian,
  data = mald,
  seed = 6725,
  file = "cache/ch-regression-cat-rt_bm_1"
)
```

Treatment contrasts are applied by default: you do not need to create a dummy variable yourself or tell brms to use that coding (which is both a blessing and a curse).

```{r}
#| label: rt-bm-1-summ
summary(rt_bm_1)
```

## Indexing of categorical predictors

$$
\begin{align}
y_i & \sim Gaussian(\mu_i, \sigma)\\
\mu_i & = \beta_{\text{W}[i]}\\
\end{align}
$$

```{r}
#| label: rt-bm-2

rt_bm_2 <- brm(
  RT ~ 0 + IsWord,
  family = gaussian,
  data = mald,
  seed = 6725,
  file = "cache/ch-regression-cat-rt_bm_2"
)
```

```{r}
#| label: rt-bm-2-summ
summary(rt_bm_2)
```

## More than two levels

```{r}
#| label: eu-vot

eu_vot <- read_csv("data/egurtzegi2020/eu_vot.csv")
eu_vot
```

```{r}
#| label: eu-vot-three

eu_vot <- eu_vot |> 
  mutate(
    phonation = case_when(
      phone %in% c("p", "t", "k") ~ "voiceless",
      phone %in% c("b", "d", "g") ~ "voiced",
      phone %in% c("ph", "th", "kh") ~ "aspirated"
    ),
    VOT = VOT * 1000
  )

```

```{r}
#| label: fig-eu-vot-dens

eu_vot |> 
  drop_na(phonation) |> 
  ggplot(aes(VOT, fill = phonation)) +
  geom_density(alpha = 0.5)

```

```{r}
#| label: fig-eu-vot-jit

eu_vot |> 
  drop_na(phonation) |> 
  ggplot(aes(phonation, VOT)) +
  geom_jitter(alpha = 0.5, width = 0.2)

```

```{r}
#| label: vot_bm

vot_bm <- brm(
  VOT ~ 0 + phonation,
  family = gaussian,
  data = eu_vot,
  seed = 6725,
  file = "cache/ch-regression-cat-vot_bm"
)

```

`Warning: Rows containing NAs were excluded from the model.`

```{r}
#| label: vot-bm-summ
summary(vot_bm)
```
