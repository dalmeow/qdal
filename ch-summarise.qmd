# Summarise and group data

![](https://img.shields.io/badge/Area-R-green)

```{r}
#| label: setup
#| include: false

library(tidyverse)
library(webexercises)
```

## Summarise with `summarise()`

When you work with data, you always want to get summary measures for most of the variables in the data. Data reports usually include summary measures. It is also important to understand which summary measure is appropriate for which type of variable, which was covered in the previous section. Now, you will learn how to obtain summary measures using the `summarise()` function from the [dplyr](https://dplyr.tidyverse.org) tidyverse package. `summarise()` takes at least two arguments: (1) the tibble to summarise, (2) one or more summary functions applied to columns in the tibble. Let's practice with the data from @song2020 you read in @sec-read-data. We want to get a measure of central tendency and dispersion for the reaction times, in the `RT` column. In order to decide which measures to pick, think about the nature of the `RT` variable. Rection times is a numeric and continuous statistical variable, and it can only have positive values. So the mean and standard deviations are appropriate measures. Let's start with the mean of the reaction time column `RT`. First, create a new R script (or continue writing in an existing script), attach the tidyverse and read the `song2020/shallow.csv` file into a variable called `shallow`.

```{r}
#| label: shallow
#| echo: false
#| message: false

library(tidyverse)
shallow <- read_csv("data/song2020/shallow.csv")
```

Now let's calculate the mean of `RT` with `summarise()`. Here is the code with its output:

```{r}
#| label: mean-3

summarise(shallow, RT_mean = mean(RT))

```

Great! The mean reaction times of the entire sample is 867.3592 ms. Sometimes you might want to round the numbers. You can round numbers with the `round()` function. For example:

```{r}
#| label: round

num <- 867.3592
round(num)
round(num, 1)
round(num, 2)

```

The second argument of the `round()` function sets the number of decimals to round to (by default, it is `0`, so the number is rounded to the nearest integer, that is, to the nearest whole number with no decimal values). Let's recalculate the mean by rounding it this time.

```{r}
#| label: mean-4

summarise(shallow, RT_mean = round(mean(RT)))
```

What if we want also the standard deviation? Easy: we use the `sd()` function. (Round the mean and SD with the `round()` function in your code).

```{r}
#| label: sd

# round the mean and SD
summarise(shallow, RT_mean = mean(RT), RT_sd = sd(RT))

```

Now we know that reaction times are on average 867 ms long and have a standard deviation of about 293 ms (rounded to the nearest integer). Let's go all the way and also get the minimum and maximum RT values with the `min()` and `max()` functions (round all the summary measures).

::: callout-warning
### Exercise 1

Complete this code to also get the minimum and maximum RT and round all measures to the nearest integer.

```{r}
#| label: minmax-ex
#| eval: false

summarise(
  shallow,
  RT_mean = mean(RT), RT_sd = sd(RT),
  RT_min = ..., RT_max = ...
)

```
:::

:::: {.callout-important collapse="true"}
### Solution

The functions for minumum and maximum are just a few lines above! Have you tried filling the code before seeing the solution?

::: {.callout-important collapse="true"}
### Show me

```{r}
#| label: minmax-ex-solution
#| eval: false

summarise(
  shallow,
  RT_mean = round(mean(RT)), RT_sd = round(sd(RT)),
  RT_min = round(min(RT)), RT_max = round(max(RT))
)

```
:::
::::

Fab! When writing a data report, you could write something like this.

> Reaction times are on average 867 ms long (SD = 293 ms), with values ranging from 0 to 1994 ms.

We won't go into the details of what standard deviations are, but you can just think of them as a relative measure of how dispersed the data are around the mean: the higher the SD, the greater the dispersion around the mean, i.e. the greater the variability in the data. When required, you can use the `median()` function to calculate the median, instead of the `mean()`. Go ahead and calculate the median reaction times in the data. Is it similar to the mean?

::: callout-warning
### Exercise 2

Calculate the median of RTs in the `shallow` data.
:::

## `NA`s

Most base R functions, like `mean()`, `sd()`, `median()` and so on, behave unexpectedly if the vector they are used on contains `NA` values. `NA` is a special object in R, that indicates that a value is **N**ot **A**vailable, meaning that that observation does not have a value (or that the value was not observed in that case). For example, in the following numeric vector, there are 5 objects:

```{r}
#| label: a

a <- c(3, 5, 3, NA, 4)
```

Four are numbers and one is `NA`. If you calculate the mean of `a` with `mean()` something strange happens.

```{r}
#| label: a-mean

mean(a)
```

The functions returns `NA`. This is because by default when just one value in the vector is `NA` then operations on the vector will return `NA`.

```{r}
#| label: a-mss

mean(a)
sum(a)
sd(a)
```

If you want to discard the `NA` values when operating on a vector that contains them, you have to set the `na.rm` (for "`NA` remove") argument to `TRUE`.

```{r}
#| label: a-narm

mean(a, na.rm = TRUE)
sum(a, na.rm = TRUE)
sd(a, na.rm = TRUE)
```

:::: callout-note
#### Quiz 1

```{r}
#| label: quiz-1
#| results: asis
#| echo: false

opts_1a <- c(
   "It changes `NA`s to `FALSE`.",
   "It converts `NA`s to `0`s.",
   answer = "It removes `NA`s before taking the mean."
)

cat("a. What does the `na.rm` argument of `mean()` do?", longmcq(opts_1a))

opts_1b <- c(
   answer = "`NA`.",
   "`0`.",
   "`10.66`."
)

cat("b. Which is the mean of `c(4, 23, NA, 5)` when `na.rm` has the default value?", longmcq(opts_1b))
```

::: {.callout-tip collapse="true"}
#### Hint

Check the documentation of `?mean`.
:::
::::

## Grouping data with `group_by()`.

XXX.

## Summary table of summary measures

To conclude, here is a table that summarises when each measure should be used, depending on the nature of the variable. You can use this table as a cheat-sheet. Green cells indicate that the measure is appropriate for the variable, red cells indicates that they are not and should not be used, and orange cells indicate you should exercise caution when using those measures with those variables.

![](img/measures-overview.png)
