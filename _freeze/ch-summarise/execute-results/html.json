{
  "hash": "f028d89140f45a7afe024b15fa8b4644",
  "result": {
    "engine": "knitr",
    "markdown": "# Summarise and group data {#sec-summarise}\n\n![](https://img.shields.io/badge/Area-R-green)\n\n\n\n## Summarise with `summarise()`\n\nWhen you work with data, you always want to get summary measures for most of the variables in the data. Data reports usually include summary measures. It is also important to understand which summary measure is appropriate for which type of variable, which was covered in the previous section. Now, you will learn how to obtain summary measures using the `summarise()` function from the [dplyr](https://dplyr.tidyverse.org) tidyverse package. `summarise()` takes at least two arguments: (1) the tibble to summarise, (2) one or more summary functions applied to columns in the tibble. Let's practice with the data from @song2020 you read in @sec-read-data. We want to get a measure of central tendency and dispersion for the reaction times, in the `RT` column. In order to decide which measures to pick, think about the nature of the `RT` variable. Rection times is a numeric and continuous statistical variable, and it can only have positive values. So the mean and standard deviations are appropriate measures. Let's start with the mean of the reaction time column `RT`. First, create a new R script (or continue writing in an existing script), attach the tidyverse and read the `song2020/shallow.csv` file into a variable called `shallow`.\n\n\n::: {.cell}\n\n:::\n\n\nNow let's calculate the mean of `RT` with `summarise()`. Here is the code with its output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(shallow, RT_mean = mean(RT))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"RT_mean\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"867.3592\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nGreat! The mean reaction times of the entire sample is 867.3592 ms. Sometimes you might want to round the numbers. You can round numbers with the `round()` function. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum <- 867.3592\nround(num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 867\n```\n\n\n:::\n\n```{.r .cell-code}\nround(num, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 867.4\n```\n\n\n:::\n\n```{.r .cell-code}\nround(num, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 867.36\n```\n\n\n:::\n:::\n\n\nThe second argument of the `round()` function sets the number of decimals to round to (by default, it is `0`, so the number is rounded to the nearest integer, that is, to the nearest whole number with no decimal values). Let's recalculate the mean by rounding it this time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(shallow, RT_mean = round(mean(RT)))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"RT_mean\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"867\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nWhat if we want also the standard deviation? Easy: we use the `sd()` function. (Round the mean and SD with the `round()` function in your code).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# round the mean and SD\nsummarise(shallow, RT_mean = mean(RT), RT_sd = sd(RT))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"RT_mean\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"RT_sd\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"867.3592\",\"2\":\"292.9682\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow we know that reaction times are on average 867 ms long and have a standard deviation of about 293 ms (rounded to the nearest integer). Let's go all the way and also get the minimum and maximum RT values with the `min()` and `max()` functions (round all the summary measures).\n\n::: callout-warning\n### Exercise 1\n\nComplete this code to also get the minimum and maximum RT and round all measures to the nearest integer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  shallow,\n  RT_mean = mean(RT), RT_sd = sd(RT),\n  RT_min = ..., RT_max = ...\n)\n```\n:::\n\n:::\n\n:::: {.callout-important collapse=\"true\"}\n### Solution\n\nThe functions for minumum and maximum are just a few lines above! Have you tried filling the code before seeing the solution?\n\n::: {.callout-important collapse=\"true\"}\n### Show me\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(\n  shallow,\n  RT_mean = round(mean(RT)), RT_sd = round(sd(RT)),\n  RT_min = round(min(RT)), RT_max = round(max(RT))\n)\n```\n:::\n\n:::\n::::\n\nFab! When writing a data report, you could write something like this.\n\n> Reaction times are on average 867 ms long (SD = 293 ms), with values ranging from 0 to 1994 ms.\n\nWe won't go into the details of what standard deviations are, but you can just think of them as a relative measure of how dispersed the data are around the mean: the higher the SD, the greater the dispersion around the mean, i.e. the greater the variability in the data. When required, you can use the `median()` function to calculate the median, instead of the `mean()`. Go ahead and calculate the median reaction times in the data. Is it similar to the mean?\n\n::: callout-warning\n### Exercise 2\n\nCalculate the median of RTs in the `shallow` data.\n:::\n\n## `NA`s\n\nMost base R functions, like `mean()`, `sd()`, `median()` and so on, behave unexpectedly if the vector they are used on contains `NA` values. `NA` is a special object in R, that indicates that a value is **N**ot **A**vailable, meaning that that observation does not have a value (or that the value was not observed in that case). For example, in the following numeric vector, there are 5 objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(3, 5, 3, NA, 4)\n```\n:::\n\n\nFour are numbers and one is `NA`. If you calculate the mean of `a` with `mean()` something strange happens.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nThe functions returns `NA`. This is because by default when just one value in the vector is `NA` then operations on the vector will return `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nIf you want to discard the `NA` values when operating on a vector that contains them, you have to set the `na.rm` (for \"`NA` remove\") argument to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(a, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.75\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(a, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9574271\n```\n\n\n:::\n:::\n\n\n:::: callout-note\n#### Quiz 1\n\na. What does the `na.rm` argument of `mean()` do? <div class='webex-radiogroup' id='radio_KZIEUNACGN'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KZIEUNACGN\" value=\"\"></input> <span>It changes `NA`s to `FALSE`.</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KZIEUNACGN\" value=\"\"></input> <span>It converts `NA`s to `0`s.</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KZIEUNACGN\" value=\"answer\"></input> <span>It removes `NA`s before taking the mean.</span></label></div>\nb. Which is the mean of `c(4, 23, NA, 5)` when `na.rm` has the default value? <div class='webex-radiogroup' id='radio_ZLNXLKNLRP'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ZLNXLKNLRP\" value=\"answer\"></input> <span>`NA`.</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ZLNXLKNLRP\" value=\"\"></input> <span>`0`.</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ZLNXLKNLRP\" value=\"\"></input> <span>`10.66`.</span></label></div>\n\n::: {.callout-tip collapse=\"true\"}\n#### Hint\n\nCheck the documentation of `?mean`.\n:::\n::::\n\n## Grouping data with `group_by()`.\n\nXXX. \n\n## Summary table of summary measures\n\nTo conclude, here is a table that summarises when each measure should be used, depending on the nature of the variable. You can use this table as a cheat-sheet. Green cells indicate that the measure is appropriate for the variable, red cells indicates that they are not and should not be used, and orange cells indicate you should exercise caution when using those measures with those variables. Gray cells indicate that it's mathematically impossible to apply that measure to that type of variable.\n\n![](img/measures-overview.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}